<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mok&#39;s blog</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 31 Aug 2018 07:13:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>My First Blog</title>
      <link>http://yoursite.com/2018/08/31/hello-world/</link>
      <guid>http://yoursite.com/2018/08/31/hello-world/</guid>
      <pubDate>Fri, 31 Aug 2018 07:13:58 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;终于把博客搭建好了，值得记录的一天！&lt;/p&gt;
&lt;/blockquote&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>终于把博客搭建好了，值得记录的一天！</p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/08/31/hello-world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Promise的实现</title>
      <link>http://yoursite.com/2018/08/30/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://yoursite.com/2018/08/30/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Thu, 30 Aug 2018 07:31:55 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;如何实现Promise&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>如何实现Promise</p></blockquote><a id="more"></a><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h2><blockquote><p>primise是异步编程的一种解决方法，可以避免回调地狱的问题，最早由社区提出和实现，现为ES6语言标准。所谓promise，字面意思是承诺，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果；从语法上说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的API，各种异步操作都可以用同样的方法进行处理。</p></blockquote><p>关于promise的基础知识，网上很多博客都有讲解，也可以参考参考阮一峰老师的<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ECMAScript 6 入门</a>。</p><hr><h2 id="Promise的实现"><a href="#Promise的实现" class="headerlink" title="Promise的实现"></a>Promise的实现</h2><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   function Promise(fn)&#123;</span><br><span class="line">       //deferreds用来存储回调函数</span><br><span class="line">var value = null, deferreds = [];</span><br><span class="line">       //then相当于订阅过程</span><br><span class="line">this.then =function(onFulfilled)&#123;</span><br><span class="line">deferreds.push(onFulfilled);</span><br><span class="line">&#125;;</span><br><span class="line">       //resolve相当于发布过程</span><br><span class="line">function resolve(value)&#123;</span><br><span class="line">deferreds.forEach(function(deferred)&#123;</span><br><span class="line">deferred(value);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免resolve执行时deferreds为空"><a href="#避免resolve执行时deferreds为空" class="headerlink" title="避免resolve执行时deferreds为空"></a>避免resolve执行时deferreds为空</h3><p>避免传入的不是异步函数，resolve方法会先执行，此时没有调用then，使得defferreds队列还是空的，不合预期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   function Promise(fn) &#123;</span><br><span class="line">var value = null,</span><br><span class="line">deferreds = [];</span><br><span class="line">this.then = function(onFulfilled) &#123;</span><br><span class="line">deferreds.push(onFulfilled);</span><br><span class="line">&#125;;</span><br><span class="line">       //这里将resolve放到了栈底，所以then会先执行（如果有then的话）</span><br><span class="line">function resolve(value) &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">deferreds.forEach(function(deferred) &#123;</span><br><span class="line">deferred(value);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line">fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态引入"><a href="#状态引入" class="headerlink" title="状态引入"></a>状态引入</h3><p>如果当异步操作执行成功之后，内部resolve已经执行完毕，再调用then方法注册回调函数就不会再执行了。<br>要解决这个问题，需要引入规范中的三个状态：pending、fulfilled、rejected。如果你了解过promise的基础知识，这三个状态肯定不会陌生了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   function Promise(fn) &#123;</span><br><span class="line">var value = null,</span><br><span class="line">    state = null,</span><br><span class="line">deferreds = [];</span><br><span class="line">this.then = function(onFulfilled) &#123;</span><br><span class="line">if(state===&apos;pending&apos;)&#123;</span><br><span class="line">deferreds.push(onFulfilled);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">onFulfilled(vaule);</span><br><span class="line">return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function resolve(newValue) &#123;</span><br><span class="line">          //当resolve时改变状态为fulfilled</span><br><span class="line">value = newValue;</span><br><span class="line">state = &apos;fulfilled&apos;;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">deferreds.forEach(function(deferred) &#123;</span><br><span class="line">deferred(value);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line">fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调then的时候做个判断，如果是pending说明resolve方法还没执行，那么我们将回调函数加到队列等待resolve即可，如果是fulfilled，说明resolve已经执行，那么我们直接执行新加入的回调函数。</p><h3 id="串型promise-实现链式调用"><a href="#串型promise-实现链式调用" class="headerlink" title="串型promise,实现链式调用"></a>串型promise,实现链式调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   function Promise(fn) &#123;</span><br><span class="line">var value = null,</span><br><span class="line">state = null,</span><br><span class="line">deferreds = [];</span><br><span class="line">this.then = function(onFulfilled) &#123;</span><br><span class="line">return new Promise(function(resolve) &#123;</span><br><span class="line">handle(&#123;</span><br><span class="line">onFulfilled: onFulfilled || null,</span><br><span class="line">resolve: resolve</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function handle(deferred) &#123;</span><br><span class="line">if (state === &apos;pending&apos;) &#123;</span><br><span class="line">deferreds.push(onFulfilled);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">var ret = deferred.onFulfilled(vaule);</span><br><span class="line">deferred.resolve(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function resolve(newValue) &#123;</span><br><span class="line">if(newValue &amp;&amp; (typeof newValue === &apos;Object&apos; || typeof newValue === &apos;function&apos;))&#123;</span><br><span class="line">var then=newValue.then;</span><br><span class="line">then.call(newValue,resolve);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">value = newValue;</span><br><span class="line">state = &apos;fulfilled&apos;;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">deferreds.forEach(function(deferred) &#123;</span><br><span class="line">handle(deferred);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分理解起来会比较困难，then中返回一个新的promise实例，在新实例中调用内部方法handle，handle传入一个回调函数和一个当前新promise的resolve方法构成的对象。内部方法判断状态，如果为pending状态，此时resolve还未执行，则将回调函数入队列，否则直接调用传入的回调函数，并将回调的返回值传入resolve方法。针对返回值的不同，可能是一个新的promise，所以在resolve方法中做一个判断，如果是对象或是函数则取出新promise的then，并调用这个then；如果不是对象或是函数，则直接resolve。</p><h3 id="增加rejected状态"><a href="#增加rejected状态" class="headerlink" title="增加rejected状态"></a>增加rejected状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">   function Promise(fn) &#123;</span><br><span class="line">var value = null,</span><br><span class="line">state = null,</span><br><span class="line">deferreds = [];</span><br><span class="line">this.then = function(onFulfilled) &#123;</span><br><span class="line">return new Promise(function(resolve) &#123;</span><br><span class="line">handle(&#123;</span><br><span class="line">onFulfilled: onFulfilled || null,</span><br><span class="line">onRejected: onRejected || null,</span><br><span class="line">resolve: resolve,</span><br><span class="line">reject: reject</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function handle(deferred) &#123;</span><br><span class="line">if (state === &apos;pending&apos;) &#123;</span><br><span class="line">deferreds.push(onFulfilled);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">var cb=state===&apos;fulfilled&apos;?deferred.onFulfilled : deferred.onRejected;</span><br><span class="line">if(cb===null)&#123;</span><br><span class="line">cb=state===&apos;fulfilled&apos;?deferred.resolve : deferred.reject;</span><br><span class="line">cb(value);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">var ret = cb(value);</span><br><span class="line">deferred.resolve(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function resolve(newValue) &#123;</span><br><span class="line">if(newValue &amp;&amp; (typeof newValue === &apos;Object&apos; || typeof newValue === &apos;function&apos;))&#123;</span><br><span class="line">var then=newValue.then;</span><br><span class="line">then.call(newValue,resolve);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">value = newValue;</span><br><span class="line">state = &apos;fulfilled&apos;;</span><br><span class="line">finale();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reject(reason)&#123;</span><br><span class="line">state = &apos;rejected&apos;;</span><br><span class="line">value = reason;</span><br><span class="line">finale();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function finale()&#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">deferreds.forEach(function(deferred) &#123;</span><br><span class="line">handle(deferred);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(resolve,reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理resolve和reject的回调函数异常"><a href="#处理resolve和reject的回调函数异常" class="headerlink" title="处理resolve和reject的回调函数异常"></a>处理resolve和reject的回调函数异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   //修改handle函数</span><br><span class="line">  function handle(deferred) &#123;</span><br><span class="line">if (state === &apos;pending&apos;) &#123;</span><br><span class="line">deferreds.push(onFulfilled);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">var cb=state===&apos;fulfilled&apos;?deferred.onFulfilled : deferred.onRejected,ret;</span><br><span class="line">if(cb===null)&#123;</span><br><span class="line">cb=state===&apos;fulfilled&apos;?deferred.resolve : deferred.reject;</span><br><span class="line">cb(value);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">ret=cb(value);</span><br><span class="line">deferred.resolve(ret);</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">deferred.reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，promise的实现基本完成了，其实刚开始理解起来并不容易，陆陆续续看过几篇博主的实现过程，多多少少都有些不同，但整体思路是一致的，如果不能很好理解，就先记录下来，自己跟着实现一遍，再慢慢去理解会好很多。文章的最后附上几个我认为写的不错的、有关promise实现的博客链接，希望对你有帮助。</p><p>参考链接：<a href="https://blog.csdn.net/yibingxiong1/article/details/68075416" target="_blank" rel="noopener">实现一个自己的promise</a>、<a href="https://www.jianshu.com/p/a89a8e5d6636" target="_blank" rel="noopener">手把手教你实现Promise</a>、<a href="https://github.com/forthealllight/blog/issues/4" target="_blank" rel="noopener">实现一个完美符合Promise/A+规范的Promise</a>、<a href="https://segmentfault.com/a/1190000012664201" target="_blank" rel="noopener">ES6实现完整Promise</a>.</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/08/30/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>浮动清除</title>
      <link>http://yoursite.com/2018/03/29/%E6%B5%AE%E5%8A%A8%E6%B8%85%E9%99%A4/</link>
      <guid>http://yoursite.com/2018/03/29/%E6%B5%AE%E5%8A%A8%E6%B8%85%E9%99%A4/</guid>
      <pubDate>Thu, 29 Mar 2018 11:48:02 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;css中的浮动与清除&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>css中的浮动与清除</p></blockquote><a id="more"></a><h2 id="浮动-float-是什么？"><a href="#浮动-float-是什么？" class="headerlink" title="浮动-float-是什么？"></a>浮动-float-是什么？</h2><blockquote><p>浮动元素会脱离文档流并向左/右浮动，直到碰到父元素或者另一个浮动元素。</p></blockquote><p>浮动元素可以用来实现文字环绕，浮动元素可以设置内联排列和宽高，介于inline和block之间的存在。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>导致父元素高度坍塌</li><li>可能遮挡普通元素</li><li>父元素的背景、边框、边距（margin、padding)等不能正常显示</li></ul><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-clear：both"><a href="#1-clear：both" class="headerlink" title="1: clear：both"></a>1: clear：both</h3><p>直接在包含块末端添加一个标签，并且使用clear: both，来清除浮动对页面的影响。clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。</p><pre><code>&lt;div class=&quot;box-wrapper&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>注意：是通过在别的元素上清除浮动来实现撑开高度的，而不是在浮动元素上。如果是对浮动元素本身使用，即使上下增加了清除空间，也无任何意义。一般情况下不使用，因为这种清除浮动的方式会增加页面的标签，语义不明确，造成结构的混乱，一旦代码量增加，后期比较难维护。</p><h3 id="2：-触发浮动父元素的BCF清除浮动"><a href="#2：-触发浮动父元素的BCF清除浮动" class="headerlink" title="2： 触发浮动父元素的BCF清除浮动"></a>2： 触发浮动父元素的BCF清除浮动</h3><p>BFC（Block Formatting Contexts ）全称是块状格式化上下文，它是按照块级盒子布局的。具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。</p><p>简单介绍下其特性：</p><ul><li>同一个 BFC 下外边距会发生折叠</li><li>BFC 可以包含浮动的元素（清除浮动）  </li><li>BFC可以阻止元素被浮动元素覆盖</li></ul><p>那么怎么触发BFC呢？</p><ul><li>body 根元素</li><li>float: left或right</li><li>position: absolute或fixed</li><li>dispaly: table-cell或table-caption或inline-block或flex或inline-flex</li><li>overflow: hiden或auto或scroll</li></ul><p>建立一个BFC，根据BFC的布局规则将浮动子元素包含进来，我们可以给父元素设置overflow:auto来简单的实现BFC清除浮动，但是为了兼容IE最好用overflow:hidden。但是这样元素阴影或下拉菜单会被截断，比较局限。</p><p>直接将包含块设置为float。即可建立BFC。但这种做法不推荐，因为整体浮动会影响其他的布局。</p><h3 id="3：伪元素实现-推荐"><a href="#3：伪元素实现-推荐" class="headerlink" title="3：伪元素实现(推荐)"></a>3：伪元素实现(推荐)</h3><p>对父元素使用</p><pre><code>//伪元素清除浮动方案.clearfix: after {     dispaly: block;      content: &quot; &quot;; //设内容为空     clear: both; //清除浮动 } .clearfix {      zoom: 1; //兼容IE，以支持IE6/7 }//双伪元素清除浮动，加入：before以解决子元素边距margin-top折叠问题 .clearfix: before,.clearfix: after {      display: table;      content: &quot; &quot;; } .clearfix: after {      clear: both; } .clearfix {      zoom: 1; }</code></pre><blockquote><p>另外，伪类选择器中有使用一个冒号和两个冒号的情况，区别在于单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。如果只需要兼容现代浏览器如 webkit、firefox、opera等浏览器，对于伪元素采用双冒号的写法，若是非要兼容IE浏览器，用CSS2的单冒号写法比较安全。</p><ul><li>CSS 伪类用于向某些选择器添加特殊的效果。</li><li>CSS 伪元素用于将特殊的效果添加到某些选择器。</li></ul></blockquote><p>添加:before就必须将display设置为table。主要原理：display设置为table时会出现一个匿名表格单元格（anonymous table-cell），从而创建一个新的BFC，根据BFC的布局规则，会使margin-top不重叠。如果没有防止重叠的需求，完全可以精简代码，使用上一种写法。</p><p>另一种写法：</p><pre><code>.clearfix: after {     display: block;     clear: both;     content: &quot;&quot;;     visibility: hidden;     height: 0; }.clearfix {     zoom:1; }</code></pre><p>将display设置为block是因为<code>:after</code>是伪元素，要想获得clear属性必须将他转换为block。添加<code>visibility: hidden; height: 0;</code>是让包含块末端看起来不那么乱，所以直接隐藏起来。</p><p>总的来说，清除浮动有两大方法，使用clear属性和建立BFC。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/29/%E6%B5%AE%E5%8A%A8%E6%B8%85%E9%99%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo+GithubPages&amp;Coding搭建博客</title>
      <link>http://yoursite.com/2018/03/11/Hexo-GithubPages/</link>
      <guid>http://yoursite.com/2018/03/11/Hexo-GithubPages/</guid>
      <pubDate>Sun, 11 Mar 2018 14:22:04 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;我是如何搭建博客的&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>我是如何搭建博客的</p></blockquote><a id="more"></a><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>关于我的博客自然也是看了很多网上的教程才一步一步搭建成功的，多多少少都会免不了一番折腾，基本上是跟着网上各式各样的教程一步一步搭建成功的。搭建博客并不难，但是为了丰富个人的博客页面（瞎折腾），陆陆续续的也花了不少时间，总算完工了，所以决定写一篇文章来记录下大致的搭建过程。</p></blockquote><h2 id="搭建博客的原因："><a href="#搭建博客的原因：" class="headerlink" title="搭建博客的原因："></a>搭建博客的原因：</h2><blockquote><p>记录生活，记录学习上的点滴（啧啧）。每个人都有自己的理由，无论你是码农，还是其他职业，你都值得并且有能力去搭建一个博客。</p></blockquote><hr><h2 id="你需要了解的知识："><a href="#你需要了解的知识：" class="headerlink" title="你需要了解的知识："></a>你需要了解的知识：</h2><blockquote><p>搭建博客的方法：</p></blockquote><ul><li>博客平台注册，如博客园，CSDN,新浪博客等。  </li><li>博客框架搭建。  </li><li>代码手写。 </li></ul><p>如标题所言，我用的是hexo博客框架搭建的，并利用GitHubPages和CodingPages作为托管平台。</p><h3 id="HEXO"><a href="#HEXO" class="headerlink" title="HEXO"></a>HEXO</h3><p>Hexo是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上。</p><h3 id="GitHubPages"><a href="#GitHubPages" class="headerlink" title="GitHubPages"></a>GitHubPages</h3><p>GitHubPages可以被认为是用户编写的、托管在github上的静态网页。由于它的空间免费稳定,可以用于介绍托管在github上的Project或者搭建网站。</p><h3 id="CodingPages"><a href="#CodingPages" class="headerlink" title="CodingPages"></a>CodingPages</h3><p>CodingPages是一个静态网页托管和演示服务，其实和GitHubPages功能一样，用于托管博客、项目官网等静态网页，也可以部署开源博客、CMS等动态网页。</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>可作为免费的远程仓库，托管自己的代码。还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>关于这些知识，如果你想了解的更多，建议自行百度。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p><strong>搭建步骤：</strong></p><ol><li>获得个人网站域名</li><li>GitHub创建个人仓库</li><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>推送网站</li><li>绑定域名</li><li>更换主题</li></ol><blockquote><p>其实网上搭建博客的方法很多，不同框架，不同平台，不同主题。搭建的方法也是大同小异，不一定哪一篇教程就适合你，完全照搬某个教程也不一定能成功，还是得多参考，多尝试，自己理解了大致方法就明白自己要做哪一步该做哪一步。这里我给上主要的教程链接。</p></blockquote><p>首先看这个：<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a>。有些地方并不详细，比如搭建个人仓库的部分，可以自行百度下详细教程。在安装hexo的时候，我也出现了问题，可以参考这个教程的做法：<a href="https://blog.csdn.net/working_harder/article/details/52437783" target="_blank" rel="noopener">使用github+Hexo人人都能拥有一个美美的博客</a>。接着是绑定域名的部分，实践发现只要添加两条解析记录就可以了，看图：</p><p><img src="http://p4r569uff.bkt.clouddn.com/ali.jpg" alt="Alt text"></p><p>一些其它问题你都可以参照这个博客的做法来解决：<a href="http://jmyblog.top/" target="_blank" rel="noopener">…Miss.j BlogDiary…</a>。</p><p>博客搭建完成后，如果在浏览器中显示错误，那么可能是域名设置和绑定部分出现了错误。编写好文章后，可以通过先输入hexo s命令，在浏览器中输入： <a href="http://localhost:400/" target="_blank" rel="noopener">http://localhost:400/</a> 在本地预览效果，修改完成后，再推送到github上。</p><p>想要把网站弄得<strong>个性化</strong>一点，参考这几个教程(<strong>针对next主题</strong>)：<a href="https://zhuanlan.zhihu.com/p/28128674" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a>、<a href="https://www.jianshu.com/p/5973c05d7100" target="_blank" rel="noopener">2小时还你一个集打赏、评论、RSS功能于一身的个人博客</a>、<a href="https://www.jianshu.com/p/e75f208b5290" target="_blank" rel="noopener">Hexo博客搭建及NexT主题个性化设置</a>。如果你也想为自己的网站添加宠物，经个人实践，之前教程中的方法已经行不通了，你可以参考这两个教程：<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a>、<a href="https://www.ohyhello.com/" target="_blank" rel="noopener">ohyhello</a>。</p><h2 id="博客备份"><a href="#博客备份" class="headerlink" title="博客备份"></a>博客备份</h2><p>当你搭建好一个博客后，最好还是给自己的博客备份一下，万一哪天不小心把博客文件删了，或者是换电脑了，没有hexo的源文件还是很麻烦的。你可以选择拷贝一份到你的u盘上或者是云端的办法来备份，这里我使用的是备份到github上。老规矩，链接附上：<a href="https://www.jianshu.com/p/baab04284923" target="_blank" rel="noopener">怎么去备份你的Hexo博客</a>、<a href="https://blog.csdn.net/u012195214/article/details/72721065" target="_blank" rel="noopener">使用Hexo搭建博客，备份至GitHub过程 </a>。</p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2><p>最后，我想说，看完这篇文章，你可能会说怎么一大堆链接啊，看的心累。呃…..这个嘛……事实上我搭建博客的时候，看的教程自然不止这上面分享的这么多，以上分享的教程个人觉得还是比较实用的。搭建博客其实就是在考验你自己解决问题的能力和耐心，方法很多，教程更是多不胜数，这些教程在网上都能找到，我相信只要你有耐心，建好自己的博客是迟早的事。如果能靠自己的能力完成，那一定是满满的成就感。所以说，像我这种渣渣都可以，你肯定也是可以的！O__O</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/11/Hexo-GithubPages/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
