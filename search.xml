<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2018%2F08%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[终于把博客搭建好了，值得记录的一天！]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise的实现]]></title>
    <url>%2F2018%2F08%2F30%2FPromise%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[如何实现Promise 什么是Promise? primise是异步编程的一种解决方法，可以避免回调地狱的问题，最早由社区提出和实现，现为ES6语言标准。所谓promise，字面意思是承诺，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果；从语法上说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的API，各种异步操作都可以用同样的方法进行处理。 关于promise的基础知识，网上很多博客都有讲解，也可以参考参考阮一峰老师的ECMAScript 6 入门。 Promise的实现基础实现123456789101112131415 function Promise(fn)&#123; //deferreds用来存储回调函数 var value = null, deferreds = []; //then相当于订阅过程 this.then =function(onFulfilled)&#123; deferreds.push(onFulfilled); &#125;; //resolve相当于发布过程 function resolve(value)&#123; deferreds.forEach(function(deferred)&#123; deferred(value); &#125;); &#125; fn(resolve);&#125; 避免resolve执行时deferreds为空避免传入的不是异步函数，resolve方法会先执行，此时没有调用then，使得defferreds队列还是空的，不合预期。 12345678910111213141516 function Promise(fn) &#123; var value = null, deferreds = []; this.then = function(onFulfilled) &#123; deferreds.push(onFulfilled); &#125;; //这里将resolve放到了栈底，所以then会先执行（如果有then的话） function resolve(value) &#123; setTimeout(function() &#123; deferreds.forEach(function(deferred) &#123; deferred(value); &#125;); &#125;, 0); &#125; fn(resolve);&#125; 状态引入如果当异步操作执行成功之后，内部resolve已经执行完毕，再调用then方法注册回调函数就不会再执行了。要解决这个问题，需要引入规范中的三个状态：pending、fulfilled、rejected。如果你了解过promise的基础知识，这三个状态肯定不会陌生了。 12345678910111213141516171819202122232425 function Promise(fn) &#123; var value = null, state = null, deferreds = []; this.then = function(onFulfilled) &#123; if(state===&apos;pending&apos;)&#123; deferreds.push(onFulfilled); return this; &#125; onFulfilled(vaule); return this; &#125;; function resolve(newValue) &#123; //当resolve时改变状态为fulfilled value = newValue; state = &apos;fulfilled&apos;; setTimeout(function() &#123; deferreds.forEach(function(deferred) &#123; deferred(value); &#125;); &#125;, 0); &#125; fn(resolve);&#125; 调then的时候做个判断，如果是pending说明resolve方法还没执行，那么我们将回调函数加到队列等待resolve即可，如果是fulfilled，说明resolve已经执行，那么我们直接执行新加入的回调函数。 串型promise,实现链式调用1234567891011121314151617181920212223242526272829303132333435363738 function Promise(fn) &#123; var value = null, state = null, deferreds = []; this.then = function(onFulfilled) &#123; return new Promise(function(resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;); &#125;); &#125;; function handle(deferred) &#123; if (state === &apos;pending&apos;) &#123; deferreds.push(onFulfilled); return; &#125; var ret = deferred.onFulfilled(vaule); deferred.resolve(ret); &#125; function resolve(newValue) &#123; if(newValue &amp;&amp; (typeof newValue === &apos;Object&apos; || typeof newValue === &apos;function&apos;))&#123; var then=newValue.then; then.call(newValue,resolve); return; &#125; value = newValue; state = &apos;fulfilled&apos;; setTimeout(function() &#123; deferreds.forEach(function(deferred) &#123; handle(deferred); &#125;); &#125;, 0); &#125;&#125; 这部分理解起来会比较困难，then中返回一个新的promise实例，在新实例中调用内部方法handle，handle传入一个回调函数和一个当前新promise的resolve方法构成的对象。内部方法判断状态，如果为pending状态，此时resolve还未执行，则将回调函数入队列，否则直接调用传入的回调函数，并将回调的返回值传入resolve方法。针对返回值的不同，可能是一个新的promise，所以在resolve方法中做一个判断，如果是对象或是函数则取出新promise的then，并调用这个then；如果不是对象或是函数，则直接resolve。 增加rejected状态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 function Promise(fn) &#123; var value = null, state = null, deferreds = []; this.then = function(onFulfilled) &#123; return new Promise(function(resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;); &#125;; function handle(deferred) &#123; if (state === &apos;pending&apos;) &#123; deferreds.push(onFulfilled); return; &#125; var cb=state===&apos;fulfilled&apos;?deferred.onFulfilled : deferred.onRejected; if(cb===null)&#123; cb=state===&apos;fulfilled&apos;?deferred.resolve : deferred.reject; cb(value); return; &#125; var ret = cb(value); deferred.resolve(ret); &#125; function resolve(newValue) &#123; if(newValue &amp;&amp; (typeof newValue === &apos;Object&apos; || typeof newValue === &apos;function&apos;))&#123; var then=newValue.then; then.call(newValue,resolve); return; &#125; value = newValue; state = &apos;fulfilled&apos;; finale(); &#125; function reject(reason)&#123; state = &apos;rejected&apos;; value = reason; finale(); &#125; function finale()&#123; setTimeout(function() &#123; deferreds.forEach(function(deferred) &#123; handle(deferred); &#125;); &#125;, 0); &#125; fn(resolve,reject);&#125; 处理resolve和reject的回调函数异常12345678910111213141516171819 //修改handle函数 function handle(deferred) &#123; if (state === &apos;pending&apos;) &#123; deferreds.push(onFulfilled); return; &#125; var cb=state===&apos;fulfilled&apos;?deferred.onFulfilled : deferred.onRejected,ret; if(cb===null)&#123; cb=state===&apos;fulfilled&apos;?deferred.resolve : deferred.reject; cb(value); return; &#125; try&#123; ret=cb(value); deferred.resolve(ret); &#125;catch(e)&#123; deferred.reject(e); &#125;&#125; 到这里，promise的实现基本完成了，其实刚开始理解起来并不容易，陆陆续续看过几篇博主的实现过程，多多少少都有些不同，但整体思路是一致的，如果不能很好理解，就先记录下来，自己跟着实现一遍，再慢慢去理解会好很多。文章的最后附上几个我认为写的不错的、有关promise实现的博客链接，希望对你有帮助。 参考链接：实现一个自己的promise、手把手教你实现Promise、实现一个完美符合Promise/A+规范的Promise、ES6实现完整Promise.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>ES6</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动清除]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%B5%AE%E5%8A%A8%E6%B8%85%E9%99%A4%2F</url>
    <content type="text"><![CDATA[css中的浮动与清除 浮动-float-是什么？ 浮动元素会脱离文档流并向左/右浮动，直到碰到父元素或者另一个浮动元素。 浮动元素可以用来实现文字环绕，浮动元素可以设置内联排列和宽高，介于inline和block之间的存在。 特点 导致父元素高度坍塌 可能遮挡普通元素 父元素的背景、边框、边距（margin、padding)等不能正常显示 解决方法1: clear：both直接在包含块末端添加一个标签，并且使用clear: both，来清除浮动对页面的影响。clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。 &lt;div class=&quot;box-wrapper&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 注意：是通过在别的元素上清除浮动来实现撑开高度的，而不是在浮动元素上。如果是对浮动元素本身使用，即使上下增加了清除空间，也无任何意义。一般情况下不使用，因为这种清除浮动的方式会增加页面的标签，语义不明确，造成结构的混乱，一旦代码量增加，后期比较难维护。 2： 触发浮动父元素的BCF清除浮动BFC（Block Formatting Contexts ）全称是块状格式化上下文，它是按照块级盒子布局的。具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。 简单介绍下其特性： 同一个 BFC 下外边距会发生折叠 BFC 可以包含浮动的元素（清除浮动） BFC可以阻止元素被浮动元素覆盖 那么怎么触发BFC呢？ body 根元素 float: left或right position: absolute或fixed dispaly: table-cell或table-caption或inline-block或flex或inline-flex overflow: hiden或auto或scroll 建立一个BFC，根据BFC的布局规则将浮动子元素包含进来，我们可以给父元素设置overflow:auto来简单的实现BFC清除浮动，但是为了兼容IE最好用overflow:hidden。但是这样元素阴影或下拉菜单会被截断，比较局限。 直接将包含块设置为float。即可建立BFC。但这种做法不推荐，因为整体浮动会影响其他的布局。 3：伪元素实现(推荐)对父元素使用 //伪元素清除浮动方案 .clearfix: after { dispaly: block; content: &quot; &quot;; //设内容为空 clear: both; //清除浮动 } .clearfix { zoom: 1; //兼容IE，以支持IE6/7 } //双伪元素清除浮动，加入：before以解决子元素边距margin-top折叠问题 .clearfix: before,.clearfix: after { display: table; content: &quot; &quot;; } .clearfix: after { clear: both; } .clearfix { zoom: 1; } 另外，伪类选择器中有使用一个冒号和两个冒号的情况，区别在于单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。如果只需要兼容现代浏览器如 webkit、firefox、opera等浏览器，对于伪元素采用双冒号的写法，若是非要兼容IE浏览器，用CSS2的单冒号写法比较安全。 CSS 伪类用于向某些选择器添加特殊的效果。 CSS 伪元素用于将特殊的效果添加到某些选择器。 添加:before就必须将display设置为table。主要原理：display设置为table时会出现一个匿名表格单元格（anonymous table-cell），从而创建一个新的BFC，根据BFC的布局规则，会使margin-top不重叠。如果没有防止重叠的需求，完全可以精简代码，使用上一种写法。 另一种写法： .clearfix: after { display: block; clear: both; content: &quot;&quot;; visibility: hidden; height: 0; } .clearfix { zoom:1; } 将display设置为block是因为:after是伪元素，要想获得clear属性必须将他转换为block。添加visibility: hidden; height: 0;是让包含块末端看起来不那么乱，所以直接隐藏起来。 总的来说，清除浮动有两大方法，使用clear属性和建立BFC。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css-float</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GithubPages&Coding搭建博客]]></title>
    <url>%2F2018%2F03%2F11%2FHexo-GithubPages%2F</url>
    <content type="text"><![CDATA[我是如何搭建博客的 前言： 关于我的博客自然也是看了很多网上的教程才一步一步搭建成功的，多多少少都会免不了一番折腾，基本上是跟着网上各式各样的教程一步一步搭建成功的。搭建博客并不难，但是为了丰富个人的博客页面（瞎折腾），陆陆续续的也花了不少时间，总算完工了，所以决定写一篇文章来记录下大致的搭建过程。 搭建博客的原因： 记录生活，记录学习上的点滴（啧啧）。每个人都有自己的理由，无论你是码农，还是其他职业，你都值得并且有能力去搭建一个博客。 你需要了解的知识： 搭建博客的方法： 博客平台注册，如博客园，CSDN,新浪博客等。 博客框架搭建。 代码手写。 如标题所言，我用的是hexo博客框架搭建的，并利用GitHubPages和CodingPages作为托管平台。 HEXOHexo是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上。 GitHubPagesGitHubPages可以被认为是用户编写的、托管在github上的静态网页。由于它的空间免费稳定,可以用于介绍托管在github上的Project或者搭建网站。 CodingPagesCodingPages是一个静态网页托管和演示服务，其实和GitHubPages功能一样，用于托管博客、项目官网等静态网页，也可以部署开源博客、CMS等动态网页。 GitHub可作为免费的远程仓库，托管自己的代码。还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。 关于这些知识，如果你想了解的更多，建议自行百度。 搭建过程搭建步骤： 获得个人网站域名 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 推送网站 绑定域名 更换主题 其实网上搭建博客的方法很多，不同框架，不同平台，不同主题。搭建的方法也是大同小异，不一定哪一篇教程就适合你，完全照搬某个教程也不一定能成功，还是得多参考，多尝试，自己理解了大致方法就明白自己要做哪一步该做哪一步。这里我给上主要的教程链接。 首先看这个：GitHub+Hexo 搭建个人网站详细教程。有些地方并不详细，比如搭建个人仓库的部分，可以自行百度下详细教程。在安装hexo的时候，我也出现了问题，可以参考这个教程的做法：使用github+Hexo人人都能拥有一个美美的博客。接着是绑定域名的部分，实践发现只要添加两条解析记录就可以了，看图： 一些其它问题你都可以参照这个博客的做法来解决：…Miss.j BlogDiary…。 博客搭建完成后，如果在浏览器中显示错误，那么可能是域名设置和绑定部分出现了错误。编写好文章后，可以通过先输入hexo s命令，在浏览器中输入： http://localhost:400/ 在本地预览效果，修改完成后，再推送到github上。 想要把网站弄得个性化一点，参考这几个教程(针对next主题)：hexo的next主题个性化教程:打造炫酷网站、2小时还你一个集打赏、评论、RSS功能于一身的个人博客、Hexo博客搭建及NexT主题个性化设置。如果你也想为自己的网站添加宠物，经个人实践，之前教程中的方法已经行不通了，你可以参考这两个教程：hexo-helper-live2d 、ohyhello。 博客备份当你搭建好一个博客后，最好还是给自己的博客备份一下，万一哪天不小心把博客文件删了，或者是换电脑了，没有hexo的源文件还是很麻烦的。你可以选择拷贝一份到你的u盘上或者是云端的办法来备份，这里我使用的是备份到github上。老规矩，链接附上：怎么去备份你的Hexo博客、使用Hexo搭建博客，备份至GitHub过程 。 THE END最后，我想说，看完这篇文章，你可能会说怎么一大堆链接啊，看的心累。呃…..这个嘛……事实上我搭建博客的时候，看的教程自然不止这上面分享的这么多，以上分享的教程个人觉得还是比较实用的。搭建博客其实就是在考验你自己解决问题的能力和耐心，方法很多，教程更是多不胜数，这些教程在网上都能找到，我相信只要你有耐心，建好自己的博客是迟早的事。如果能靠自己的能力完成，那一定是满满的成就感。所以说，像我这种渣渣都可以，你肯定也是可以的！O__O]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
</search>
